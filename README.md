# Exam c++

01

базовые UB, почему std плохо, области видимости и их затемнение 

02

все типы и UB при перевове в другую сс, операции типа & | ^ ~ >> << 

вложенные ифы, много действий в скобочках `&& is like *, || is like +`

`if (!n % 3 == 0 || n % 5 == 0)` n переделает в булл, for, while, UB с переполнением, обращение к -1 элементу, итерация по элементам массива в обратную сторону,

`break;  // stop immediately`

`continue;  // continue to the next iteration (with update)`

03

вектора, assert и ошибки с ним, vector<bool> не совсем вектор и нельзя с auto, массивы (неприятные), символы - char(обычно число)(char - 1 = int), (`static_cast<char>(c - 1)`уже символ из аски), все про string

04

stoi, eof, getline(), функции, константные ссылки на аргумент `const std::string &s`, которые убыстряют вызовы функций и не изменяют значение внутри, чтобы аргумент не копировался как параметр, `[[maybe_unused]]` какие-то значения не используются, `[[nodiscard]]` идет к функциям и говорит, что значение переменной очень важное и его обязательно нужно использовать, чтобы не игнорировать значение возвращаемое функцией, 

поехали в структуры и классы

```cpp
//перегрузка операторов
    void operator+=(const Point &other) {  //прибавляем к себе точку с названием
        //other, берем по константной ссылке, чтобы не копировать
        x += other.x; //складываем как вектора
        y += other.y;
    }
(p += p2) same as (p.operator+=(p2))
```

```cpp
int dist2() const {  // Add `const` everywhere when possible
        return x * x + y * y;
}

void print(const Point &p) { //метод принт
    std::cout << p.x << " " << p.y << "\n";

    std::cout << p.dist2() << "\n"; //тут мы не хотим поменять поля
    //поэтому задали первоначально const
    //гарантируем что ничего не меняем в структуре point
    //объект только для чтения
}
```

Конструкторы - позволяют что-то делать с переменными 

`ratio{10}.num` - `берем временный объект, берем у него значение` (файлик struct-11)

`ratio(int value) : num(value) {}` между круглой и фигурной скобкой после : все поля, которые мы ходим по-другому проинициализировать

компилятор по умолчанию компилирует конструктор по умолчанию в случае, если нет ни одного конструктора 

```cpp
// getter методы, которые возвращают нам значения из приватного поля
 int numerator() const {
     return num;
 }
 int denominator() const {
     return denom;
 }

// setter: no need actually устанавливает значение числителя и знаменателя
 void numerator(int new_value) {
     num = new_value; //поменяли числитель
     //бесполезная фигня в плане идеи, но пусть будет
 }
 void denominator(int new_value) {
     assert(new_value != 0); //не сломали инвариант
     denom = new_value;
 }
```

```cpp
friend bool eq(const Foo &a, const Foo &b) { //живет вне класса, значит нет 
доступа к приватным полям
    //можно завести геттеры, сеттеры, но не факт, что пользователю нужно знать какие значение там лежит
    //может он хочет знать равны они или нет
    //делаем свободную функцию вне класса, имеющую доступ к приватным полям
    return a.field == b.field;
    //а так это обычная функция
}
```

отличие struct от class

```
struct Foo {  //по умолчанию все поля публичные, пока мы не написали private/public
    int x = 10;
};

class Bar {   //по умолчанию все поля приватные, пока мы не поменяли
    int x = 10;
};
```

`conversion - преобразования in Russian language`

чтобы неявные преобразования сработали, достаточно написать один конструктор из одного аргумента (какой-то ебнутый файлик 01-implicit-conversation)

explicit - ключевое слово, которое ставится перед объявлением конструктора с одним параметром (или с большим числом параметров, но когда все параметры, начиная со второго, имеют значения по умолчанию) и предотвращает неявное преобразование типов при инициализации

 + там еще есть все перегрузки операторов

05

как нельзя называть переменные, совместимость, область видимости, те если функции ссылаются друг на друга, нужно в правильном порядке сверху вниз их объявлять 

НО внутри структурки пофиг, сначала он читает всю структуру, а потом смотрит кто от кого вызывается

неполный тип - это мы знаем, что существует, но еще не знаем какие в нем поля будут incomplete type

для решения создадим метод за пределами класса, те он будет обращаться к тек полям у структуры и тд

френд функция же не будет вызываться на каком-то объекте, а имеет доступ к приватным полям любого объекта структуры и опеределяется за пределами класса(the same as simple function)

если в классе 200 методов, ты мы сначала объявим их, а потом ниже реализацию

не использовать круглые скобки для инициализации по умолчанию`The most vexing parse`

линковка - делаем несколько независимых файлов cpp - единицы трансляции, их компилятор будет компилировать и получать какие-то промеждуточные представления и склеивать их. С -с можем их по отдельности скомпилить и слинковать

UB линкуем bouble и float  `Ill Formed, No Diagnostic Required, API, ABI`

One Definition Rule - если есть программа, где программа это несколько translation unitов, то у каждой функции/сущности должно бть ровно одно определение, ловит компилятор. НО если в разных файлах объявить одинаковые функции, но с разным кол-вом элементов, то уже не проблем  

```cpp
void foo(int);
void foo() {}
```

gcc линкует программы на языке си, g++ линкует с++

-static “зашивает” внутрь экзэшника всю стандартную библиотеку (write и глобальные переменнные) 

структурки - должно быть одинаковое объявление и там и там 

“команда #include - бесконечно тупая и просто копирует содержимое в другой файлик”

`namespace` говорим, что какие-то переменные и функции лежат внутри пространства имен

при поиске идем изнутри 

```cpp
namespace ns1 {
int x;

void foo() {
    std::cout << "foo1\n";
}
}  // namespace ns1

namespace ns2 {
void foo() {
    std::cout << "foo2\n";
}
}  // namespace ns2

namespace ns3 {}
int main(){ 
ns1::foo();  // unqualified name lookup + qualified
ns2::foo();
ns1::x = 10;
// ns3::foo();  // compilation error (внутри namespace не нашли)
```

`Argument-Dependent Lookup aka Koenig Lookup` откуда пошли :: смотрим namespace каждого аргумента 

hpp - определение структур, объявление функций и в начале 

`#ifndef CLI_VIEW_H_` `#define CLI_VIEW_H_` `#endif  // CLI_VIEW_H_`

в cpp ставим `#include "foo.hpp"`

06

если include ссылаются сами на себя(циклы), нужно сделать forward declaration, те инклуды с меньшим содержимым (hpp_fwd - объявление структуры)

`#include <iosfwd>  // smaller than <iostream>, only forward declarations`, чтобы после раскрытия получить единицы трансляции не в 3000 строк каждая

проблема в том, что много глобальных переменных, которые друг от друга как-то зависят, то не понятно кого в каком порядке инициализировать

(стандарт не гарантирует в каком порядке проинициализировать глобальные переменные)

если попробовать скомпилить файлы в разном порядке

когда мы пришли в main(), все должно быть уже проинициализированно 

```cpp
void print_hello() {
    std::ios_base::Init init;
    std::cout << "Hello World\n";
    //cout не проинициализирован, но мы его используем при объявлении
    //когда foo.hpp еще не прочелся
    //те компилятор решил, что мы берем сначала main, потом foo
}
```

влияет на кросс-платформенность 

`construct-on-first-use`

static - видна только внутри этой функции, локальна для функции, создается один раз и живет все время работы программы и сохраняет старое значение, те функция внутри все инициализирует и проблем с линковкой не будет 

`"unnamed namespace" namespace {`

 - при проблемах с линковкой снаружи 

07

all about алгоритмы, sort, set, iterators, map, полный линейный порядок, `UB: irreflexivity,` 

разбиваем пару на составляющие, 

```cpp
auto &[x, y] = p; //берем по ссылке
// auto &x = p.first;
// auto &y = p.second;
```

если не хочу менять и копировать

```cpp
for (const auto &[key, value] : m) {
    std::cout << key << " --> " << value << "\n";
}
```

```cpp
//Компаратор - это специальная функция, которая умеет сравнивать два объекта и 
//решить, больше-меньше-равно.
std::sort(v.begin(), v.end(), [&](int a, int b) {
    // middle++;  // UB: not a comparator at all выход, тк компоратор во время 
    //работы меняет поведение 
    //по умолчанию лямбда не использует локальные переменные
    //но если написать [&], то использует
```

`lower_bound` первый больший или равный заданного

`upper_bound` первый элемент строго больший

```cpp
assert(*std::lower_bound(s.begin(), s.end(), 10) == 10);  // O(n) for std::set
assert(*s.lower_bound(10) == 10);  // O(log)
```

08

Как писать двусвязный список

Указатели - позволяют сохранить не индекс, а некоторое спец значение, которое указывает на каку-то структуру определенного типа

`nullptr` указатель указывает вникуда

`node_ptr *prev = nullptr, *next = nullptr;` ”почти как ссылка и еще кое-что”

ссылка всегда куда-то указывает, указателю пофиг

указатель может указывать на разные значения 

`a.next = &b; b.prev = &a;  // `&` means 'take address of'` связали а и б 

`*a.prev;  // UB: dereference of nullptr` разыменовываем указание на nullptr, низя

`Foo *f = this; //всегда указатель на тек элемент` this всегда заменяется на адрес объекта `f.foo();  // this == &f`

Каждому new должен быть delete, иначе не прикольно `Double-free` и `Leak otherwise`

```cpp
Foo *f = new Foo; //указатель на новый выделенный объект, который будет
//жить все время работы программы
```

Нельзя удалять локальную переменную через delete, он работает только с new

умный указатель, нельзя копировать

```cpp
std::unique_ptr<Foo> f;
std::cout << (f == nullptr) << "\n";
f = std::unique_ptr<Foo>(new Foo()); same as f = std::make_unique<Foo>();
//сам вызывает new, в нем можно хранить nullptr, указатели
//он думает он единственный, те когда умирает, вызывает delete

//но может быть так
std::unique_ptr<Foo> f = std::make_unique<Foo>();
    Foo *ptr = f.get();
    assert(ptr->v[3] == 4);
    return ptr; //низя
```

```cpp
std::unique_ptr<Foo> g = std::move(f); //можно переместить
//теперь в f лежит nullptr
assert(f == nullptr);
vec.emplace_back(std::move(g));
assert(g == nullptr);
//теперь в векторе 2 nullptrа
```

`assert(f->v[2] == 3);` берем указатель на 2 элемент вектора

с указателями можно прикалываться в наследовании

```cpp
Derived *dptr = &d;
Base *bptr = dptr;
```

Наследование

- это просто один из механизмов языка C++, который позволяет делать некоторые новые вещи. В других языках иногда наследования вообще нет (Haskell, Rust), но на них прекрасно пишут код, просто механизмы другие.

(подробней в мастхэвах)

`operator<<(std::ostream &os, ....)`

ostream базовый класс для кучи разных видов потока вывода

virtual, move, unique_ptr и тд и тп в маствэвах 

09

`Automatic storage duration.`

`Static storage duration.` - переменная, которая управляется автоматически компилятором, но один раз создаются, а удаляются в самом конце программы после main(глобальные переменные, static лежит в глобальной памяти) например массивчик не на стеке `static int data[1'000'000];`

статические поля классов 

как и глобальная, но действуют ограничения типа private. Внутри класса `static int calls;` снаружи `int Counter::calls = 10;`

`dynamic storage duration`

`shadowing (-Wshadow); independent x`

весячая ссылка - указывает на некорректный объект в памяти, переменной нет, но ссылка есть 

```cpp
std::vector<int>& foo() { //ссылка на лок переменную
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> &vec1 = foo();  // Not UB
    std::cout << vec1.size() << "\n";  // UB

    std::vector<int> vec2 = foo();  // UB, because copy constructor вектор уже умер
    std::cout << vec2.size() << "\n";  // UB
}
```

`invalid` ссылки или итераторы 

наследование

`derivedcast (C++), downcast (others)`

`RTTI` полиморфные классы `typeid`

автоматическое время жизни

`default initialization`

`direct initialization`

`dynamic_cast` на наследника, тогда если по ссылке действительно был ребенок, то все ок, вернет указатель на тот же объект, иначе nullptr. Работает еще с ссылками, если нечего вернуть, то `exception thrown` остановка выполнения программы 

```cpp
if (const Derived2 *d2 = dynamic_cast<const Derived2 *>(&b);
    d2 != nullptr && d2->value > 10) {  // C++17: if with init statement
    std::cout << "Derived2 " << d2->value << " > 10\n";
}
```

10

ура библиотеки 

почти любая библиотека состоит из 2х частей заголовки и бинарный код

динамическая бибилиотека - “отдельные приложения” у них есть свои глобальные переменные, своя куча, зависимости, набор кода, набор классов 

1 - используем когда нужно вынести что-то из каждого файла и использовать почти везде, код в отдельном файлике на компе, экономим место

2 - нужно что-то взломать и тп

как работает cmake 

как скомпилить boost в cmake

```cpp
find_package(Boost 1.74 REQUIRED filesystem) # найти библиотеку
include_directories(${Boost_INCLUDE_DIRS})  # -I инклуды из библиотеки
link_directories(${Boost_LIBRARY_DIRS})  # -L файлики из библиотеки

include_directories(include)  # Should be before add_executable
add_executable(main src/main.cpp src/foo.cpp)
target_link_libraries(main ${Boost_LIBRARIES})  # -l линкуем

```

каждый плагин или мод - наследник класса. Это какой-то объект и у него есть 2 метода, имя, что-то посчитать и диструктор, который должен быть у каждого в иерархии наследования 

```cpp
namespace plugins_demo {
class BOOST_SYMBOL_VISIBLE abstract_plugin {
public:
    virtual const std::string &name() const = 0;
    virtual float calculate(float x, float y) = 0;
    virtual ~abstract_plugin() = default;
};
```

еще про move

11

диструктор

Многопоточность

на стеке

```cpp
int data = 1234;
std::thread t([&]() { //один новый поток
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    //делает паузу в программе на 500 млс
    std::cout << "Hello from thread! data=" << data << "\n";
    data += 10;
});
std::cout << "Waiting for it...\n";
t.join();
//ждет пока 2 поток закончит выполняться
// Подождать поток t, освобождает ресурсы потока.
std::cout << "data is " << data << "\n";
// Вызывается ~thread(), к этому моменту обязательно сделать join().

std::thread(worker, a, std::ref(b)).join();
//передает аргументы в поток

t.detach();
    //говорим, что не будем ждать завершения потока
    //нам не интересен результат потока
    // Обещаем больше не делать join(), теперь ОС отвечает за сборку мусора в потоке.
    // Возникает только если нам вообще ничего от потока `t` никогда не будет нужно.
    // Единственный разумный пример: мы создаём сетевой сервер, который в бесконечном цикле плодит потоки для клиентов.
    std::cout << "data is " << data << "\n";
    // После завершения main() завершается программа, но поток всё ещё работает — UB (обращения к умершим глобальным переменным).
```

```cpp
std::mutex m; //взаимное исключение либо один либо второй
    //делает lock() пока вторая не скажет unlock()
    //так строчки не пересекутся
    //но тк mutex локальный, у каждого потока свой и они перемешаются

std::mutex m; //глобальный
//но не гарантирует что будет давать потокам доступ по очереди
void writeln(const std::string &s) {
    m.lock();
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
    m.unlock();
}

int main() {
    std::thread t([]() {
        for (;;) {
            writeln("Hello from the second thread");
            std::this_thread::yield();  // Костыль!
            //потоки чаще переключаются
        }
    });
    for (;;) {
        writeln("Hello from the main thread");
        std::this_thread::yield();
    }
}
```

`std::unique_lock l{m};` вместо m.lock(); и m.unlock();

еще создаем переменную - l, которая будет держать m, когда будет уничтожаться l, вызовется unlock

в качестве конструктора - m

в конструкторе вызовет lock

в диструкторе вызовет unlock

UB с потоками `data_snapshot = data; data++;` и тп 

каждый доступ к локальной перменной должен быть защещен mutex 

`std::atomic<int> data = 0; //тривиальные операции не перемешиваются` делает операцию атомарной, нельзя синхрлнизировать друг с другом 

гонка данных - data race

```cpp
auto worker = [&]() {
    for (int i = 0; i < N; i++) {
        data++;
    }
};
//гонка данных
//оба потока взяли одновременно 10 и получили оба 11 после 2х операций
```

`volatile` - запрещает делать оптимизации с переменными, но не влияет на потоки

```cpp
std::thread consumer([&]() { //потребляет значения
    std::cout << "Consumer started\n";
    std::string input = input_future.get();
    //передаем значение
    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
    //ждем
    std::cout << "Got string: " << input << "\n";
    //выводим
```

12

`Variable Length Array (VLA)`

`array-to-pointer decay` ссылка на нулевой массив
